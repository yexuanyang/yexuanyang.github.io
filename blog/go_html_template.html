<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><meta charSet="utf-8"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"/><link rel="preload" href="/_next/static/css/71c3005585daf34a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/71c3005585daf34a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d30dc8bfc45a058b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d30dc8bfc45a058b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-b96261d959dd50e7.js" defer=""></script><script src="/_next/static/chunks/main-5641a5f61dc27c0f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a20eeb038bec1046.js" defer=""></script><script src="/_next/static/chunks/106-a71b11894cb18610.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-99312d6fcde602f9.js" defer=""></script><script src="/_next/static/20UMOGqztqylNLBnC72Ga/_buildManifest.js" defer=""></script><script src="/_next/static/20UMOGqztqylNLBnC72Ga/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout"><header class="nav"><div class="nav-container"><a href="/" class="nav-brand">人生何处不青山</a><div class="nav-links"><a href="/" class="nav-link">首页</a><a href="/blog" class="nav-link">文章</a><a href="/categories" class="nav-link">分类</a><a href="/about" class="nav-link">关于我</a></div></div></header><main class="container"><article class="article_container__uEGY_"><header class="article_header__Dfu8i"><h1 class="article_title__Kemkb">Go文本和HTML模板使用指南</h1><div class="article_meta__EQMJH"><span class="article_date__8Zsel">2023-07-31</span><a class="article_category__FEprG" href="/articles?category=GO">GO</a></div><div class="article_tags__SeZQL"><a class="article_tag__xFxqV" href="/articles?tag=GO">#<!-- -->GO</a></div></header><div class="article_content__xXtEi"><h2>文本模板</h2>
<p>创建模板字符串：</p>
<pre><code class="language-go">const templ = `{{.TotalCount}} issues:
{{range .Items}}----------------------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf "%.64s"}}
Age:    {{.CreatedAt | daysAgo}} days
{{end}}`

</code></pre>
<p>当前值“.”最初被初始化为调用模板时的参数；{{range }} {{ end}}是一个循环；"|"表示前一个表达式的输出作为后面的输入，类似Unix的管道，printf类似fmt.printf；daysAgo是函数，在编译模板的时候可以指定函数是什么</p>
<h2>编译模板</h2>
<pre><code class="language-go">var report = template.Must(template.New("issuelist").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ))

func main() {
    result, err := github.SearchIssues(os.Args[1:])
    if err != nil {
        log.Fatal(err)
    }
    if err := report.Execute(os.Stdout, result); err != nil {
        log.Fatal(err)
    }
}

</code></pre>
<p>上述代码实现功能如下：</p>
<ul>
<li>使用 <code>template.Must</code>检测template创建是否成功，函数 <code>template.New</code>创建一个模板</li>
<li><code>.Funcs()</code>里面使用 <code>template.FuncMap{key:value}</code>来创建模板中函数名和实现了的函数的对应</li>
<li><code>.Parse()</code>将传入的template字符串转成template类型</li>
<li>使用 <code>.Execute()</code>函数使用template类型的对象，第一个参数传入流，第二个参数传入要使用模板的对象，这里应该传入结构体，初始化的时候"."就会变成结构体的值，<code>.Number</code>就会变成结构体内的Number成员</li>
</ul>
<h2>练习</h2>
<p>描述：创建一个web服务器，查询一次GitHub，然后生成BUG报告、里程碑和对应的用户信息</p>
<p>思路：</p>
<ul>
<li>需要定义输出的模板，输出bug报告，里程碑，对应的用户信息</li>
<li>需要使用http.HandleFunc来创建句柄函数处理路由和http.ListenAndServe来创建webServer的侦听端口和ip地址</li>
<li>需要获取用户的输入作为查找的关键词，获取方式：<code>r.URL.Query().Get("key")</code></li>
</ul>
<p>程序：</p>
<pre><code class="language-go">package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"net/http"
)

const (
	BaseUrl = "https://api.github.com/search/issues"
	Temp    = `
	&#x3C;h1>{{.TotalCount}} issues&#x3C;/h1>
	&#x3C;table>
	&#x3C;tr style='text-align: left'>
	  &#x3C;th>#&#x3C;/th>
	  &#x3C;th>State&#x3C;/th>
	  &#x3C;th>User&#x3C;/th>
	  &#x3C;th>Title&#x3C;/th>
	&#x3C;/tr>
	{{range .Items}}
	&#x3C;tr>
	  &#x3C;td>&#x3C;a href='{{.HTMLURL}}'>{{.Number}}&#x3C;/a>&#x3C;/td>
	  &#x3C;td>{{.State}}&#x3C;/td>
	  &#x3C;td>&#x3C;a href='{{.User.HTMLURL}}'>{{.User.Login}}&#x3C;/a>&#x3C;/td>
	  &#x3C;td>&#x3C;a href='{{.HTMLURL}}'>{{.Title}}&#x3C;/a>&#x3C;/td>
	&#x3C;/tr>
	{{end}}
	&#x3C;/table>
	`
)

type User struct {
	// 用户名
	Login   string `json:"login"`
	HTMLURL string `json:"html_url"`
}

type Issue struct {
	Number  int
	HTMLURL string `json:"html_url"`
	Title   string
	State   string
	User    *User
}

type IssuesSearchResult struct {
	TotalCount int `json:"total_count"`
	Items      []*Issue
}

func server() {
	http.HandleFunc("/", handle)
	http.ListenAndServe("127.0.0.1:5020", nil)
}
func handle(w http.ResponseWriter, r *http.Request) {
	report := template.Must(template.New("issueInfo").Parse(Temp))
	q := r.URL.Query().Get("key")
	if q == "" {
		fmt.Fprint(w, "请输入要检索的词")
	}
	res, _ := http.Get(fmt.Sprintf("%s?q=%s", BaseUrl, q))
	result := &#x26;IssuesSearchResult{}
	if err := json.NewDecoder(res.Body).Decode(result); err != nil {
		panic(err)
	}
	report.Execute(w, result)
}
func main() {
	server()
}

</code></pre>
<p>程序实现两个函数：</p>
<ul>
<li>server用来建立侦听的服务器和绑定处理特定路由使用的函数</li>
<li>handle是处理特定路由的句柄</li>
</ul>
<p>在handle中使用 <code>r.URL().Query().Get("key")</code>获取查询给出的key关键词的值，例如 <code>127.0.0.1:5020/?key=go</code>则获取到go这个字符串，将其作为检索词传入api接口中</p>
</div><footer class="article_footer__5JN_G"><div class="article_navigation__fJhBJ"><a class="article_backButton__FZQSF" href="/blog">返回文章列表</a></div></footer></article></main><footer class="footer"><p>© 2024 个人博客. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"go_html_template","contentHtml":"\u003ch2\u003e文本模板\u003c/h2\u003e\n\u003cp\u003e创建模板字符串：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003econst templ = `{{.TotalCount}} issues:\r\n{{range .Items}}----------------------------------------\r\nNumber: {{.Number}}\r\nUser:   {{.User.Login}}\r\nTitle:  {{.Title | printf \"%.64s\"}}\r\nAge:    {{.CreatedAt | daysAgo}} days\r\n{{end}}`\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当前值“.”最初被初始化为调用模板时的参数；{{range }} {{ end}}是一个循环；\"|\"表示前一个表达式的输出作为后面的输入，类似Unix的管道，printf类似fmt.printf；daysAgo是函数，在编译模板的时候可以指定函数是什么\u003c/p\u003e\n\u003ch2\u003e编译模板\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003evar report = template.Must(template.New(\"issuelist\").\r\n    Funcs(template.FuncMap{\"daysAgo\": daysAgo}).\r\n    Parse(templ))\r\n\r\nfunc main() {\r\n    result, err := github.SearchIssues(os.Args[1:])\r\n    if err != nil {\r\n        log.Fatal(err)\r\n    }\r\n    if err := report.Execute(os.Stdout, result); err != nil {\r\n        log.Fatal(err)\r\n    }\r\n}\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码实现功能如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003etemplate.Must\u003c/code\u003e检测template创建是否成功，函数 \u003ccode\u003etemplate.New\u003c/code\u003e创建一个模板\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.Funcs()\u003c/code\u003e里面使用 \u003ccode\u003etemplate.FuncMap{key:value}\u003c/code\u003e来创建模板中函数名和实现了的函数的对应\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.Parse()\u003c/code\u003e将传入的template字符串转成template类型\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003e.Execute()\u003c/code\u003e函数使用template类型的对象，第一个参数传入流，第二个参数传入要使用模板的对象，这里应该传入结构体，初始化的时候\".\"就会变成结构体的值，\u003ccode\u003e.Number\u003c/code\u003e就会变成结构体内的Number成员\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e练习\u003c/h2\u003e\n\u003cp\u003e描述：创建一个web服务器，查询一次GitHub，然后生成BUG报告、里程碑和对应的用户信息\u003c/p\u003e\n\u003cp\u003e思路：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e需要定义输出的模板，输出bug报告，里程碑，对应的用户信息\u003c/li\u003e\n\u003cli\u003e需要使用http.HandleFunc来创建句柄函数处理路由和http.ListenAndServe来创建webServer的侦听端口和ip地址\u003c/li\u003e\n\u003cli\u003e需要获取用户的输入作为查找的关键词，获取方式：\u003ccode\u003er.URL.Query().Get(\"key\")\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e程序：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"html/template\"\r\n\t\"net/http\"\r\n)\r\n\r\nconst (\r\n\tBaseUrl = \"https://api.github.com/search/issues\"\r\n\tTemp    = `\r\n\t\u0026#x3C;h1\u003e{{.TotalCount}} issues\u0026#x3C;/h1\u003e\r\n\t\u0026#x3C;table\u003e\r\n\t\u0026#x3C;tr style='text-align: left'\u003e\r\n\t  \u0026#x3C;th\u003e#\u0026#x3C;/th\u003e\r\n\t  \u0026#x3C;th\u003eState\u0026#x3C;/th\u003e\r\n\t  \u0026#x3C;th\u003eUser\u0026#x3C;/th\u003e\r\n\t  \u0026#x3C;th\u003eTitle\u0026#x3C;/th\u003e\r\n\t\u0026#x3C;/tr\u003e\r\n\t{{range .Items}}\r\n\t\u0026#x3C;tr\u003e\r\n\t  \u0026#x3C;td\u003e\u0026#x3C;a href='{{.HTMLURL}}'\u003e{{.Number}}\u0026#x3C;/a\u003e\u0026#x3C;/td\u003e\r\n\t  \u0026#x3C;td\u003e{{.State}}\u0026#x3C;/td\u003e\r\n\t  \u0026#x3C;td\u003e\u0026#x3C;a href='{{.User.HTMLURL}}'\u003e{{.User.Login}}\u0026#x3C;/a\u003e\u0026#x3C;/td\u003e\r\n\t  \u0026#x3C;td\u003e\u0026#x3C;a href='{{.HTMLURL}}'\u003e{{.Title}}\u0026#x3C;/a\u003e\u0026#x3C;/td\u003e\r\n\t\u0026#x3C;/tr\u003e\r\n\t{{end}}\r\n\t\u0026#x3C;/table\u003e\r\n\t`\r\n)\r\n\r\ntype User struct {\r\n\t// 用户名\r\n\tLogin   string `json:\"login\"`\r\n\tHTMLURL string `json:\"html_url\"`\r\n}\r\n\r\ntype Issue struct {\r\n\tNumber  int\r\n\tHTMLURL string `json:\"html_url\"`\r\n\tTitle   string\r\n\tState   string\r\n\tUser    *User\r\n}\r\n\r\ntype IssuesSearchResult struct {\r\n\tTotalCount int `json:\"total_count\"`\r\n\tItems      []*Issue\r\n}\r\n\r\nfunc server() {\r\n\thttp.HandleFunc(\"/\", handle)\r\n\thttp.ListenAndServe(\"127.0.0.1:5020\", nil)\r\n}\r\nfunc handle(w http.ResponseWriter, r *http.Request) {\r\n\treport := template.Must(template.New(\"issueInfo\").Parse(Temp))\r\n\tq := r.URL.Query().Get(\"key\")\r\n\tif q == \"\" {\r\n\t\tfmt.Fprint(w, \"请输入要检索的词\")\r\n\t}\r\n\tres, _ := http.Get(fmt.Sprintf(\"%s?q=%s\", BaseUrl, q))\r\n\tresult := \u0026#x26;IssuesSearchResult{}\r\n\tif err := json.NewDecoder(res.Body).Decode(result); err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treport.Execute(w, result)\r\n}\r\nfunc main() {\r\n\tserver()\r\n}\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e程序实现两个函数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eserver用来建立侦听的服务器和绑定处理特定路由使用的函数\u003c/li\u003e\n\u003cli\u003ehandle是处理特定路由的句柄\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在handle中使用 \u003ccode\u003er.URL().Query().Get(\"key\")\u003c/code\u003e获取查询给出的key关键词的值，例如 \u003ccode\u003e127.0.0.1:5020/?key=go\u003c/code\u003e则获取到go这个字符串，将其作为检索词传入api接口中\u003c/p\u003e\n","title":"Go文本和HTML模板使用指南","date":"2023-07-31","category":"GO","tags":["GO"],"summary":"介绍Go语言中文本模板和HTML模板的使用方法和最佳实践","views":0}},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"go_html_template"},"buildId":"20UMOGqztqylNLBnC72Ga","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>