<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1" data-next-head=""/><meta charSet="utf-8"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"/><link rel="preload" href="/_next/static/css/71c3005585daf34a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/71c3005585daf34a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d30dc8bfc45a058b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d30dc8bfc45a058b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-b96261d959dd50e7.js" defer=""></script><script src="/_next/static/chunks/main-5641a5f61dc27c0f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a20eeb038bec1046.js" defer=""></script><script src="/_next/static/chunks/106-a71b11894cb18610.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-99312d6fcde602f9.js" defer=""></script><script src="/_next/static/20UMOGqztqylNLBnC72Ga/_buildManifest.js" defer=""></script><script src="/_next/static/20UMOGqztqylNLBnC72Ga/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout"><header class="nav"><div class="nav-container"><a href="/" class="nav-brand">人生何处不青山</a><div class="nav-links"><a href="/" class="nav-link">首页</a><a href="/blog" class="nav-link">文章</a><a href="/categories" class="nav-link">分类</a><a href="/about" class="nav-link">关于我</a></div></div></header><main class="container"><article class="article_container__uEGY_"><header class="article_header__Dfu8i"><h1 class="article_title__Kemkb">Go Map的使用指南</h1><div class="article_meta__EQMJH"><span class="article_date__8Zsel">2023-07-31</span><a class="article_category__FEprG" href="/articles?category=GO">GO</a></div><div class="article_tags__SeZQL"><a class="article_tag__xFxqV" href="/articles?tag=GO">#<!-- -->GO</a></div></header><div class="article_content__xXtEi"><h2>key类型</h2>
<p>可以是任何可以使用==或!=比较的类型；数组，切片，结构体不能作为key类型；基本数据类型和接口类型可以作为key类型</p>
<p>如果要使用结构体作为key类型，需要提供key（）和hash（）方法</p>
<h2>value类型</h2>
<p>任意类型，可以使用空接口来存储任意类型，使用时需要一次<em>类型断言</em></p>
<p>value中存储函数可以实现分支的结构，使用map中的key来选择函数</p>
<pre><code class="language-go">package main
import "fmt"
func main() {
mf := map[int]func() int{
	1: func() int { return 10 },
	2: func() int { return 20 },
	5: func() int { return 50 },
}
fmt.Println(mf)
}
</code></pre>
<p>对于一个key对应多个value的情况，可以使用切片作为类型</p>
<p>例如</p>
<pre><code class="language-go">mp1 := make(map[int][]int)
mp2 := make(map[int]*[]int)
</code></pre>
<h2>初始化</h2>
<p>不赋值： <code>map1 := make(map[string]int)</code></p>
<p>赋值：<code>map1 := map[string]int{"1234":2,"keuw":12}</code></p>
<p>不要使用new来创建map，如果你错误的使用 new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未
初始化的变量并且取了它的地址</p>
<h2>赋值</h2>
<p>如果key是map的一个值， <code>map[key]</code>表示key对应的值；给key对应的值赋值方法：<code>map[key] = val1</code></p>
<p>将key的值导出 <code>v := map[key]</code>如果key不存在，那么v是value类型的空值</p>
<h2>容量</h2>
<p>在make map的时候可以指定map的容量，超出容量会自动+1作为新的容量；</p>
<p>对于提前知道容量的map或者可能快速扩容的map应当提前指定容量</p>
<p>指定方式：<code>make(map[string]int, 2)</code>第二个参数2就是容量</p>
<h2>测试键值对是否存在</h2>
<p><code>val, isPresent := map1["123"]</code>如果不存在那么isPresent是false</p>
<h2>删除键值对</h2>
<p><code>delete(map,key)</code></p>
<p>例如 <code>delete(map1,"123")</code>删除了map1中key为123的键值对</p>
<h2>for range遍历map</h2>
<pre><code class="language-go">for key,value := range map{
}
</code></pre>
<p>这样可以遍历一个map，key表示键，value表示值</p>
<p>map不是按照key排序也不是按照value排序的</p>
<p>例如：</p>
<pre><code class="language-go">capitals := map[string] string {"France":"Paris", "Italy":"Rome", "Japan":"Tokyo" }
for key := range capitals {
fmt.Println("Map item: Capital of", key, "is", capitals[key])
}

</code></pre>
<p>这段代码的输出如下：</p>
<pre><code class="language-plaintext">Map item: Capital of Italy is Rome
Map item: Capital of Japan is Tokyo
Map item: Capital of France is Paris
</code></pre>
<h2>map类型切片</h2>
<p>看下面的代码:</p>
<pre><code class="language-go">package main
import "fmt"
func main() {
// Version A:
items := make([]map[int]int, 5)
for i:= range items {
items[i] = make(map[int]int, 1)
items[i][1] = 2
}
fmt.Printf("Version A: Value of items: %v\n", items)
// Version B: NOT GOOD!
items2 := make([]map[int]int, 5)
for _, item := range items2 {
item = make(map[int]int, 1) // item is only a copy of the slice element.
item[1] = 2 // This 'item' will be lost on the next iteration.
}
fmt.Printf("Version B: Value of items: %v\n", items2)
}

</code></pre>
<p>VersionA的代码真正修改了map,但是VersionB的代码没有修改map,因为遍历的时候取出的item是map的一个复制品,在下一次迭代之后数据就丢失了,不会更改原来的map</p>
<h2>map排序</h2>
<p>map默认是无序的,如果需要排序,可以将键取出来,作为一个切片,然后对切片排序,再从map中取数据</p>
<p>如果需要有序的map,建议使用结构体切片,结构体如下:</p>
<pre><code class="language-go">type mymap strcut{
	key string
	value int
}
</code></pre>
<h2>map键值对换</h2>
<p>如果键值是一一对应的,那么可以直接使用for-range方式遍历map然后对换即可</p>
<p>如果键值是多对一,即可能不同的键有相同的值,那么对换之后一个键就有多个值,所以需要更换新map的类型</p>
<p>如果是 <code>map[string]int</code>对换,那么保险起见可以使用 <code>map[int][]string</code>作为对换之后的类型</p>
</div><footer class="article_footer__5JN_G"><div class="article_navigation__fJhBJ"><a class="article_backButton__FZQSF" href="/blog">返回文章列表</a></div></footer></article></main><footer class="footer"><p>© 2024 个人博客. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"go map","contentHtml":"\u003ch2\u003ekey类型\u003c/h2\u003e\n\u003cp\u003e可以是任何可以使用==或!=比较的类型；数组，切片，结构体不能作为key类型；基本数据类型和接口类型可以作为key类型\u003c/p\u003e\n\u003cp\u003e如果要使用结构体作为key类型，需要提供key（）和hash（）方法\u003c/p\u003e\n\u003ch2\u003evalue类型\u003c/h2\u003e\n\u003cp\u003e任意类型，可以使用空接口来存储任意类型，使用时需要一次\u003cem\u003e类型断言\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003evalue中存储函数可以实现分支的结构，使用map中的key来选择函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\r\nimport \"fmt\"\r\nfunc main() {\r\nmf := map[int]func() int{\r\n\t1: func() int { return 10 },\r\n\t2: func() int { return 20 },\r\n\t5: func() int { return 50 },\r\n}\r\nfmt.Println(mf)\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于一个key对应多个value的情况，可以使用切片作为类型\u003c/p\u003e\n\u003cp\u003e例如\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003emp1 := make(map[int][]int)\r\nmp2 := make(map[int]*[]int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e初始化\u003c/h2\u003e\n\u003cp\u003e不赋值： \u003ccode\u003emap1 := make(map[string]int)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e赋值：\u003ccode\u003emap1 := map[string]int{\"1234\":2,\"keuw\":12}\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e不要使用new来创建map，如果你错误的使用 new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未\r\n初始化的变量并且取了它的地址\u003c/p\u003e\n\u003ch2\u003e赋值\u003c/h2\u003e\n\u003cp\u003e如果key是map的一个值， \u003ccode\u003emap[key]\u003c/code\u003e表示key对应的值；给key对应的值赋值方法：\u003ccode\u003emap[key] = val1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e将key的值导出 \u003ccode\u003ev := map[key]\u003c/code\u003e如果key不存在，那么v是value类型的空值\u003c/p\u003e\n\u003ch2\u003e容量\u003c/h2\u003e\n\u003cp\u003e在make map的时候可以指定map的容量，超出容量会自动+1作为新的容量；\u003c/p\u003e\n\u003cp\u003e对于提前知道容量的map或者可能快速扩容的map应当提前指定容量\u003c/p\u003e\n\u003cp\u003e指定方式：\u003ccode\u003emake(map[string]int, 2)\u003c/code\u003e第二个参数2就是容量\u003c/p\u003e\n\u003ch2\u003e测试键值对是否存在\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eval, isPresent := map1[\"123\"]\u003c/code\u003e如果不存在那么isPresent是false\u003c/p\u003e\n\u003ch2\u003e删除键值对\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003edelete(map,key)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e例如 \u003ccode\u003edelete(map1,\"123\")\u003c/code\u003e删除了map1中key为123的键值对\u003c/p\u003e\n\u003ch2\u003efor range遍历map\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efor key,value := range map{\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样可以遍历一个map，key表示键，value表示值\u003c/p\u003e\n\u003cp\u003emap不是按照key排序也不是按照value排序的\u003c/p\u003e\n\u003cp\u003e例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ecapitals := map[string] string {\"France\":\"Paris\", \"Italy\":\"Rome\", \"Japan\":\"Tokyo\" }\r\nfor key := range capitals {\r\nfmt.Println(\"Map item: Capital of\", key, \"is\", capitals[key])\r\n}\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这段代码的输出如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-plaintext\"\u003eMap item: Capital of Italy is Rome\r\nMap item: Capital of Japan is Tokyo\r\nMap item: Capital of France is Paris\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003emap类型切片\u003c/h2\u003e\n\u003cp\u003e看下面的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\r\nimport \"fmt\"\r\nfunc main() {\r\n// Version A:\r\nitems := make([]map[int]int, 5)\r\nfor i:= range items {\r\nitems[i] = make(map[int]int, 1)\r\nitems[i][1] = 2\r\n}\r\nfmt.Printf(\"Version A: Value of items: %v\\n\", items)\r\n// Version B: NOT GOOD!\r\nitems2 := make([]map[int]int, 5)\r\nfor _, item := range items2 {\r\nitem = make(map[int]int, 1) // item is only a copy of the slice element.\r\nitem[1] = 2 // This 'item' will be lost on the next iteration.\r\n}\r\nfmt.Printf(\"Version B: Value of items: %v\\n\", items2)\r\n}\r\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVersionA的代码真正修改了map,但是VersionB的代码没有修改map,因为遍历的时候取出的item是map的一个复制品,在下一次迭代之后数据就丢失了,不会更改原来的map\u003c/p\u003e\n\u003ch2\u003emap排序\u003c/h2\u003e\n\u003cp\u003emap默认是无序的,如果需要排序,可以将键取出来,作为一个切片,然后对切片排序,再从map中取数据\u003c/p\u003e\n\u003cp\u003e如果需要有序的map,建议使用结构体切片,结构体如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype mymap strcut{\r\n\tkey string\r\n\tvalue int\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003emap键值对换\u003c/h2\u003e\n\u003cp\u003e如果键值是一一对应的,那么可以直接使用for-range方式遍历map然后对换即可\u003c/p\u003e\n\u003cp\u003e如果键值是多对一,即可能不同的键有相同的值,那么对换之后一个键就有多个值,所以需要更换新map的类型\u003c/p\u003e\n\u003cp\u003e如果是 \u003ccode\u003emap[string]int\u003c/code\u003e对换,那么保险起见可以使用 \u003ccode\u003emap[int][]string\u003c/code\u003e作为对换之后的类型\u003c/p\u003e\n","title":"Go Map的使用指南","date":"2023-07-31","category":"GO","tags":["GO"],"summary":"介绍Go语言中Map的key和value类型使用规则","views":0}},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"go map"},"buildId":"20UMOGqztqylNLBnC72Ga","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>