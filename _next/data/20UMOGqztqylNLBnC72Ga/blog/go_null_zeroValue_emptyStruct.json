{"pageProps":{"article":{"id":"go_null_zeroValue_emptyStruct","contentHtml":"<h1>go 里面的零值 , 空值 , 空结构体</h1>\n<h2>零值</h2>\n<p>声明变量的时候未初始化，那么变量会自动赋予零值；</p>\n<p><strong>对于值类型：</strong></p>\n<p>对于bool变量赋予false；对于字符串变量赋予\"\"；对于数值类型赋予0</p>\n<p><strong>对于引用类型：</strong></p>\n<p>都是nil，包括指针pointer，函数function，接口interface，切片slice，管道channel，映射map</p>\n<p><strong>注意：<code>：=</code>语法糖是实现的声明并初始化变量，所以变量是分配了内存空间的，这样就不是nil了</strong></p>\n<p>例如：</p>\n<pre><code class=\"language-go\">package main\r\n\r\nimport \"fmt\"\r\nimport \"reflect\"\r\n\r\nfunc main() {\r\n    var s1 []string\r\n    s2 := []string{} // 或者等同于 var s2 = []string{}\r\n\r\n    fmt.Println(s1 == nil) // true\r\n    fmt.Println(s2 == nil) // false\r\n\r\n    fmt.Println(reflect.DeepEqual(s1, s2)) // false\r\n\r\n    fmt.Println(reflect.DeepEqual(s1, []string{}))  // false\r\n    fmt.Println(reflect.DeepEqual(s2, []string{}))  // true\r\n}\n</code></pre>\n<p>对于空结构nil也可以调用对象的方法：</p>\n<pre><code class=\"language-go\">package main\r\n\r\nimport \"fmt\"\r\n\r\nconst defaultPath = \"/usr/bin/\"\r\n\r\ntype Config struct {\r\n    path string\r\n}\r\n\r\nfunc (c *Config) Path() string {\r\n    //如果对象c是空结构，那么返回默认的值\r\n    if c == nil {\r\n            return defaultPath\r\n    }\r\n    return c.path\r\n}\r\n\r\nfunc main() {\r\n    var c1 *Config\r\n    var c2 = &#x26;Config{\r\n            path: \"/usr/local/bin/\",\r\n    }\r\n    fmt.Println(c1.Path(), c2.Path())\r\n}\n</code></pre>\n<h2>nil</h2>\n<p>nil是 Golang 中唯一没有默认类型的非类型化的值</p>\n<p>nil不是保留关键字，可以给变量命名nil</p>\n<p>nil之间不可以比较，例如 <code>nil==nil</code>这个比较会报错</p>\n<p>对于常见引用类型，nil是他们的零值</p>\n<pre><code class=\"language-go\">package main\r\nimport \"fmt\"\r\nfunc main() {\r\n    //nil 是常见引用类型的零值\r\n    var m map[int]string\r\n    var ptr *int\r\n    var c chan int\r\n    var sl []int\r\n    var f func()\r\n    var i interface{}\r\n    fmt.Printf(\"%#v\\n\", m)\r\n    fmt.Printf(\"%#v\\n\", ptr)\r\n    fmt.Printf(\"%#v\\n\", c)\r\n    fmt.Printf(\"%#v\\n\", sl)\r\n    fmt.Printf(\"%#v\\n\", f)\r\n    //接口类型比较特殊，不能确定类型\r\n    fmt.Printf(\"%#v\\n\", i)\r\n}\n</code></pre>\n<p>输出的结果如下：</p>\n<pre><code class=\"language-plaintext\">map[int]string(nil)\r\n(*int)(nil)\r\n(chan int)(nil)\r\n[]int(nil)\r\n(func())(nil)\r\n&#x3C;nil>\n</code></pre>\n<p>不可以使用语法糖直接给变量赋值nil，例如 <code>a := nil</code>会报错，因为编译器不知道a是什么类型的</p>\n<p>可以这样赋值 <code>var a [某个结构] = nil</code>，这样a的类型是某个结构 但是值是nil</p>\n<p>对于nil的比较，nil！=nil的情况。例如：</p>\n<pre><code class=\"language-go\">    var p *int          // (T=*int,V=nil)\r\n    var i interface{}   // (T=nil,V=nil)\r\n\r\n    fmt.Println(p == i) // (T=*int, V=nil) == (T=nil, V=nil) -> false\r\n    func Foo() error {\r\n        var err *PathError = nil  // (T=*PathError, V=nil)\r\n        if bad() {\r\n            err = ErrBad\r\n        }\r\n        return err  // 这将始终返回 non-nil 错误\r\n    }\r\n\r\n    func main() {\r\n        err := Foo()\r\n        fmt.Println(err)        // &#x3C;nil>\r\n        fmt.Println(err == nil) // (T=*PathError, V=nil) == (T=nil, V=nil) -> false\r\n    }\n</code></pre>\n<p>接口要确定一个变量需要两个基础的属性Type 和 Value，只有两个都相同才相等</p>\n<h3>对于接口类型的空指针判断</h3>\n<pre><code class=\"language-go\">var p *int              // (T=*int, V=nil)\r\nvar i interface{}       // (T=nil, V=nil)\r\n\r\nfmt.Println(p == nil)   // true\r\nfmt.Println(i == nil)   // true\r\n\r\ni = p\r\n\r\nfmt.Println(i == nil)     // (T=*int, V=nil) == (T=nil, V=nil) -> false\n</code></pre>\n<p>第一个比较输出true因为编译器知道p的类型，可以在比较的时候把表达式 <code>p==nil</code>变成 <code>p==(*int)(nil)</code></p>\n<p>第三个比较输出false因为Type不一样</p>\n<p>所以对于接口类型的空指针判断不一定可以完全依靠 <code>v == nil</code>，有两种方式避免出现上述问题，第一个是用值和类型分别和nil比较；第二是使用反射包reflect</p>\n<h2>空结构</h2>\n<p>不占用任何空间</p>\n<p>嵌套空结构也不占用任何空间</p>\n<p>两个不一样的空结构可能具有相同的地址</p>\n<h2>最佳实践</h2>\n<p>如果在chan中传递消息的时候不在意值，那么可以使用 <code>chan struct{}</code>代替 <code>chan bool</code></p>\n<p>如果想避免unkeyed初始化结构，那么可以这样定义结构体</p>\n<pre><code class=\"language-go\">type Q struct {\r\nX, Y int\r\n_ struct{}\n</code></pre>\n<p>这样编译器不允许这样初始化结构体 <code>Q{1,1}</code>而必须要 <code>Q{X:1,Y:1}</code>才可以通过编译</p>\n","title":"Go语言中的零值、空值和空结构体","date":"2023-07-31","category":"GO","tags":["GO"],"summary":"详细介绍Go语言中的零值、nil值和空结构体的概念，包括它们的特点、使用场景和最佳实践","views":0}},"__N_SSG":true}