{"pageProps":{"article":{"id":"go_html_template","contentHtml":"<h2>文本模板</h2>\n<p>创建模板字符串：</p>\n<pre><code class=\"language-go\">const templ = `{{.TotalCount}} issues:\r\n{{range .Items}}----------------------------------------\r\nNumber: {{.Number}}\r\nUser:   {{.User.Login}}\r\nTitle:  {{.Title | printf \"%.64s\"}}\r\nAge:    {{.CreatedAt | daysAgo}} days\r\n{{end}}`\r\n\n</code></pre>\n<p>当前值“.”最初被初始化为调用模板时的参数；{{range }} {{ end}}是一个循环；\"|\"表示前一个表达式的输出作为后面的输入，类似Unix的管道，printf类似fmt.printf；daysAgo是函数，在编译模板的时候可以指定函数是什么</p>\n<h2>编译模板</h2>\n<pre><code class=\"language-go\">var report = template.Must(template.New(\"issuelist\").\r\n    Funcs(template.FuncMap{\"daysAgo\": daysAgo}).\r\n    Parse(templ))\r\n\r\nfunc main() {\r\n    result, err := github.SearchIssues(os.Args[1:])\r\n    if err != nil {\r\n        log.Fatal(err)\r\n    }\r\n    if err := report.Execute(os.Stdout, result); err != nil {\r\n        log.Fatal(err)\r\n    }\r\n}\r\n\n</code></pre>\n<p>上述代码实现功能如下：</p>\n<ul>\n<li>使用 <code>template.Must</code>检测template创建是否成功，函数 <code>template.New</code>创建一个模板</li>\n<li><code>.Funcs()</code>里面使用 <code>template.FuncMap{key:value}</code>来创建模板中函数名和实现了的函数的对应</li>\n<li><code>.Parse()</code>将传入的template字符串转成template类型</li>\n<li>使用 <code>.Execute()</code>函数使用template类型的对象，第一个参数传入流，第二个参数传入要使用模板的对象，这里应该传入结构体，初始化的时候\".\"就会变成结构体的值，<code>.Number</code>就会变成结构体内的Number成员</li>\n</ul>\n<h2>练习</h2>\n<p>描述：创建一个web服务器，查询一次GitHub，然后生成BUG报告、里程碑和对应的用户信息</p>\n<p>思路：</p>\n<ul>\n<li>需要定义输出的模板，输出bug报告，里程碑，对应的用户信息</li>\n<li>需要使用http.HandleFunc来创建句柄函数处理路由和http.ListenAndServe来创建webServer的侦听端口和ip地址</li>\n<li>需要获取用户的输入作为查找的关键词，获取方式：<code>r.URL.Query().Get(\"key\")</code></li>\n</ul>\n<p>程序：</p>\n<pre><code class=\"language-go\">package main\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"html/template\"\r\n\t\"net/http\"\r\n)\r\n\r\nconst (\r\n\tBaseUrl = \"https://api.github.com/search/issues\"\r\n\tTemp    = `\r\n\t&#x3C;h1>{{.TotalCount}} issues&#x3C;/h1>\r\n\t&#x3C;table>\r\n\t&#x3C;tr style='text-align: left'>\r\n\t  &#x3C;th>#&#x3C;/th>\r\n\t  &#x3C;th>State&#x3C;/th>\r\n\t  &#x3C;th>User&#x3C;/th>\r\n\t  &#x3C;th>Title&#x3C;/th>\r\n\t&#x3C;/tr>\r\n\t{{range .Items}}\r\n\t&#x3C;tr>\r\n\t  &#x3C;td>&#x3C;a href='{{.HTMLURL}}'>{{.Number}}&#x3C;/a>&#x3C;/td>\r\n\t  &#x3C;td>{{.State}}&#x3C;/td>\r\n\t  &#x3C;td>&#x3C;a href='{{.User.HTMLURL}}'>{{.User.Login}}&#x3C;/a>&#x3C;/td>\r\n\t  &#x3C;td>&#x3C;a href='{{.HTMLURL}}'>{{.Title}}&#x3C;/a>&#x3C;/td>\r\n\t&#x3C;/tr>\r\n\t{{end}}\r\n\t&#x3C;/table>\r\n\t`\r\n)\r\n\r\ntype User struct {\r\n\t// 用户名\r\n\tLogin   string `json:\"login\"`\r\n\tHTMLURL string `json:\"html_url\"`\r\n}\r\n\r\ntype Issue struct {\r\n\tNumber  int\r\n\tHTMLURL string `json:\"html_url\"`\r\n\tTitle   string\r\n\tState   string\r\n\tUser    *User\r\n}\r\n\r\ntype IssuesSearchResult struct {\r\n\tTotalCount int `json:\"total_count\"`\r\n\tItems      []*Issue\r\n}\r\n\r\nfunc server() {\r\n\thttp.HandleFunc(\"/\", handle)\r\n\thttp.ListenAndServe(\"127.0.0.1:5020\", nil)\r\n}\r\nfunc handle(w http.ResponseWriter, r *http.Request) {\r\n\treport := template.Must(template.New(\"issueInfo\").Parse(Temp))\r\n\tq := r.URL.Query().Get(\"key\")\r\n\tif q == \"\" {\r\n\t\tfmt.Fprint(w, \"请输入要检索的词\")\r\n\t}\r\n\tres, _ := http.Get(fmt.Sprintf(\"%s?q=%s\", BaseUrl, q))\r\n\tresult := &#x26;IssuesSearchResult{}\r\n\tif err := json.NewDecoder(res.Body).Decode(result); err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treport.Execute(w, result)\r\n}\r\nfunc main() {\r\n\tserver()\r\n}\r\n\n</code></pre>\n<p>程序实现两个函数：</p>\n<ul>\n<li>server用来建立侦听的服务器和绑定处理特定路由使用的函数</li>\n<li>handle是处理特定路由的句柄</li>\n</ul>\n<p>在handle中使用 <code>r.URL().Query().Get(\"key\")</code>获取查询给出的key关键词的值，例如 <code>127.0.0.1:5020/?key=go</code>则获取到go这个字符串，将其作为检索词传入api接口中</p>\n","title":"Go文本和HTML模板使用指南","date":"2023-07-31","category":"GO","tags":["GO"],"summary":"介绍Go语言中文本模板和HTML模板的使用方法和最佳实践","views":0}},"__N_SSG":true}