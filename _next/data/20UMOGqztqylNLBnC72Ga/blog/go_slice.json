{"pageProps":{"article":{"id":"go_slice","contentHtml":"<h1>go slice</h1>\n<h2>从数组中得到切片</h2>\n<p><code>c[begin:end:cap]</code></p>\n<p>如果不指定第三个参数，那么切片的容量是 <code>cap(c)-begin</code>，例如 <code>var c = []int{1,2,3,4,5,6}</code>那么 <code>cap(c) = 6</code>，那么代码 <code>b := c[1:3]</code>的长度是2，容量是5</p>\n<h2>make得到切片</h2>\n<pre><code class=\"language-go\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n    s1 := []int{0, 1, 2, 3, 8: 100} // 通过初始化表达式构造，可使用索引号。\r\n    fmt.Println(s1, len(s1), cap(s1))\r\n\r\n    s2 := make([]int, 6, 8) // 使用 make 创建，指定 len 和 cap 值。\r\n    fmt.Println(s2, len(s2), cap(s2))\r\n\r\n    s3 := make([]int, 6) // 省略 cap，相当于 cap = len。\r\n    fmt.Println(s3, len(s3), cap(s3))\r\n}\n</code></pre>\n<p>这是输出的结果：</p>\n<pre><code class=\"language-txt\">    [0 1 2 3 0 0 0 0 100] 9 9\r\n    [0 0 0 0 0 0] 6 8\r\n    [0 0 0 0 0 0] 6 6\n</code></pre>\n<p>创建的时候默认最长长度就是cap</p>\n<p>slice的底层内存结构：</p>\n<p><img src=\"../images/go_slice_p1.png\" alt=\"go_slice_p1\"></p>\n<p>可以通过&#x26;操作符直接获取底层数组</p>\n<pre><code class=\"language-go\">package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n    s := []int{0, 1, 2, 3}\r\n    p := &#x26;s[2] // *int, 获取底层数组元素指针。\r\n    *p += 100\r\n\r\n    fmt.Println(s)\r\n}\n</code></pre>\n<p>使用append在slice后添加内容\r\n<code>append(a,b...)</code>在后面追加其他切片\r\n<code>append(a,1,2,3)</code>在后面追加内容\r\n特殊场景可以把字符串接到byte切片中\r\n<code>append([]byte(\"hello\"), \"world\"...)</code>\r\nappend返回一个新的切片，切片的底层数组是相同的，输出结果不同是因为切片的长度不同导致的。如果append没有超过cap，那么新切片的cap不变，否则重新分配一个底层数组，和原数组无关，并且新切片的cap会适当变大。</p>\n<h2>slice的增长规则</h2>\n<p>在 <code>runtime\\slice.go</code>中 <code>growslice</code>函数</p>\n<pre><code class=\"language-go\">newcap := oldCap\r\ndoublecap := newcap + newcap\r\nif newLen > doublecap {\r\n    newcap = newLen\r\n} else {\r\n    const threshold = 256\r\n    if oldCap &#x3C; threshold {\r\n        newcap = doublecap\r\n    } else {\r\n        // Check 0 &#x3C; newcap to detect overflow\r\n        // and prevent an infinite loop.\r\n        for 0 &#x3C; newcap &#x26;&#x26; newcap &#x3C; newLen {\r\n            // Transition from growing 2x for small slices\r\n            // to growing 1.25x for large slices. This formula\r\n            // gives a smooth-ish transition between the two.\r\n            newcap += (newcap + 3*threshold) / 4\r\n        }\r\n        // Set newcap to the requested cap when\r\n        // the newcap calculation overflowed.\r\n        if newcap &#x3C;= 0 {\r\n            newcap = newLen\r\n        }\r\n    }\r\n}\n</code></pre>\n<pre><code class=\"language-txt\">oldPtr = pointer to the slice's backing array\r\nnewLen = new length (= oldLen + num)\r\noldCap = original slice's capacity.\r\nnum = number of elements being added\n</code></pre>\n<p>每个版本的go语言给出的源码是不一样的，根据版本不同有不同的增长方式</p>\n","title":"go slice","date":"2023-07-31","category":"GO","tags":["GO"],"summary":"介绍go slice的使用和原理","views":0}},"__N_SSG":true}