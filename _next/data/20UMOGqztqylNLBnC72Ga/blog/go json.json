{"pageProps":{"article":{"id":"go json","contentHtml":"<h2>json相关常识</h2>\n<p>json支持的类型：</p>\n<p>number</p>\n<p>array</p>\n<p>object</p>\n<p>string</p>\n<p>boolean</p>\n<p>其中object对应go语言的map，array对应slice</p>\n<h2>编码Marshal</h2>\n<pre><code class=\"language-go\">type Movie struct {\n    Title  string\n    Year   int  `json:\"released\"`\n    Color  bool `json:\"color,omitempty\"`\n    Actors []string\n}\n\nvar movies = []Movie{\n    {Title: \"Casablanca\", Year: 1942, Color: false,\n        Actors: []string{\"Humphrey Bogart\", \"Ingrid Bergman\"}},\n    {Title: \"Cool Hand Luke\", Year: 1967, Color: true,\n        Actors: []string{\"Paul Newman\"}},\n    {Title: \"Bullitt\", Year: 1968, Color: true,\n        Actors: []string{\"Steve McQueen\", \"Jacqueline Bisset\"}},\n    // ...\n}\n\n</code></pre>\n<p>使用json.Marshal函数将movies的Movie数组转换成json中的类型</p>\n<pre><code class=\"language-go\">data, err := json.Marshal(movies)\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n\n</code></pre>\n<p>输出data的信息，是一个json格式的单行字符串，不便于阅读；使用另一个函数json.MarshalIndent可以得到便于阅读的json格式字符串</p>\n<pre><code class=\"language-go\">data, err := json.MarshalIndent(movies, \"\", \"    \")\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n\n</code></pre>\n<p>json.MarshalIndent函数多传入两个参数，第一个参数：每一行输出的前缀字符串；第二个参数：每一个层级的缩进字符串。上述代码将会输出如下字符串</p>\n<pre><code class=\"language-json\">[\n    {\n        \"Title\": \"Casablanca\",\n        \"released\": 1942,\n        \"Actors\": [\n            \"Humphrey Bogart\",\n            \"Ingrid Bergman\"\n        ]\n    },\n    {\n        \"Title\": \"Cool Hand Luke\",\n        \"released\": 1967,\n        \"color\": true,\n        \"Actors\": [\n            \"Paul Newman\"\n        ]\n    },\n    {\n        \"Title\": \"Bullitt\",\n        \"released\": 1968,\n        \"color\": true,\n        \"Actors\": [\n            \"Steve McQueen\",\n            \"Jacqueline Bisset\"\n        ]\n    }\n]\n\n</code></pre>\n<p>最后一个对象末尾不需要逗号隔开。</p>\n<p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（使用了reflect反射技术）。输出的json中，把go语言中定义的结构体属性Year和属性Color变成了released和color。这是因为在结构体定义的时候增加了tag（标签）。</p>\n<pre><code class=\"language-go\">Year  int  `json:\"released\"`\nColor bool `json:\"color,omitempty\"`\n\n</code></pre>\n<p>omitempty表示当该属性的值是空值或者零值的时候，编码成json时不生成该json对象；例如movie数组中的Casablanca（Color是false）并没有输出color这个属性</p>\n<h3>标签的定义方式</h3>\n<p>一般是使用key:\"value\"的形式定义标签，value可以由多个字符串构成，不同的字符串之间使用'，'隔开。因为标签的定义需要使用双引号，所以定义的时候采用原生字符串面值的形式书写（用`包裹起来）。</p>\n<p>（使用goland可以定义完毕结构体之后键入alt+enter进入提示操作，选择add key to tags可以在后面生成一系列的tags模板）</p>\n<h2>解码Unmarshal</h2>\n<p>解码json.Unmarshal可以将json解码成go语言的结构体，第一个参数传入json字符串，第二个参数传入存储解码内容的结构体地址；可以通过给结构体定义部分属性从而只将感兴趣的内容解码</p>\n<pre><code class=\"language-go\">var titles []struct{ Title string }\nif err := json.Unmarshal(data, &#x26;titles); err != nil {\n    log.Fatalf(\"JSON unmarshaling failed: %s\", err)\n}\nfmt.Println(titles) // \"[{Casablanca} {Cool Hand Luke} {Bullitt}]\"\n\n</code></pre>\n<h2>练习</h2>\n<p>通过web编程获取github issue中的相关内容</p>\n<p>gopl.io/ch4/github/github.go（github上的链接，gopl.io是一个仓库）：</p>\n<pre><code class=\"language-go\">// Copyright © 2016 Alan A. A. Donovan &#x26; Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// See page 110.\n//!+\n\n// Package github provides a Go API for the GitHub issue tracker.\n// See https://developer.github.com/v3/search/#search-issues.\npackage github\n\nimport \"time\"\n\nconst IssuesURL = \"https://api.github.com/search/issues\"\n\ntype IssuesSearchResult struct {\n\tTotalCount int `json:\"total_count\"`\n\tItems      []*Issue\n}\n\ntype Issue struct {\n\tNumber    int\n\tHTMLURL   string `json:\"html_url\"`\n\tTitle     string\n\tState     string\n\tUser      *User\n\tCreatedAt time.Time `json:\"created_at\"`\n\tBody      string    // in Markdown format\n}\n\ntype User struct {\n\tLogin   string\n\tHTMLURL string `json:\"html_url\"`\n}\n\n//!-\n\n</code></pre>\n<p>gopl.io/ch4/github/search.go:</p>\n<pre><code class=\"language-go\">// Copyright © 2016 Alan A. A. Donovan &#x26; Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n//!+\n\npackage github\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n// SearchIssues queries the GitHub issue tracker.\nfunc SearchIssues(terms []string) (*IssuesSearchResult, error) {\n\tq := url.QueryEscape(strings.Join(terms, \" \"))\n\tresp, err := http.Get(IssuesURL + \"?q=\" + q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t//!-\n\t// For long-term stability, instead of http.Get, use the\n\t// variant below which adds an HTTP request header indicating\n\t// that only version 3 of the GitHub API is acceptable.\n\t//\n\t//   req, err := http.NewRequest(\"GET\", IssuesURL+\"?q=\"+q, nil)\n\t//   if err != nil {\n\t//       return nil, err\n\t//   }\n\t//   req.Header.Set(\n\t//       \"Accept\", \"application/vnd.github.v3.text-match+json\")\n\t//   resp, err := http.DefaultClient.Do(req)\n\t//!+\n\n\t// We must close resp.Body on all execution paths.\n\t// (Chapter 5 presents 'defer', which makes this simpler.)\n\tif resp.StatusCode != http.StatusOK {\n\t\tresp.Body.Close()\n\t\treturn nil, fmt.Errorf(\"search query failed: %s\", resp.Status)\n\t}\n\n\tvar result IssuesSearchResult\n\tif err := json.NewDecoder(resp.Body).Decode(&#x26;result); err != nil {\n\t\tresp.Body.Close()\n\t\treturn nil, err\n\t}\n\tresp.Body.Close()\n\treturn &#x26;result, nil\n}\n\n//!-\n\n</code></pre>\n<p>gopl.io/ch4/issues/main.go:</p>\n<pre><code class=\"language-go\">// Copyright © 2016 Alan A. A. Donovan &#x26; Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// See page 112.\n//!+\n\n// Issues prints a table of GitHub issues matching the search terms.\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"gopl.io/ch4/github\"\n)\n\n//!+\nfunc main() {\n\tresult, err := github.SearchIssues(os.Args[1:])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%d issues:\\n\", result.TotalCount)\n\tfor _, item := range result.Items {\n\t\tfmt.Printf(\"#%-5d %9.9s %.55s\\n\",\n\t\t\titem.Number, item.User.Login, item.Title)\n\t}\n}\n\n//!-\n\n/*\n//!+textoutput\n$ go build gopl.io/ch4/issues\n$ ./issues repo:golang/go is:open json decoder\n13 issues:\n#5680    eaigner encoding/json: set key converter on en/decoder\n#6050  gopherbot encoding/json: provide tokenizer\n#8658  gopherbot encoding/json: use bufio\n#8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal\n#5901        rsc encoding/json: allow override type marshaling\n#9812  klauspost encoding/json: string tag not symmetric\n#7872  extempora encoding/json: Encoder internally buffers full output\n#9650    cespare encoding/json: Decoding gives errPhase when unmarshalin\n#6716  gopherbot encoding/json: include field name in unmarshal error me\n#6901  lukescott encoding/json, encoding/xml: option to treat unknown fi\n#6384    joeshaw encoding/json: encode precise floating point integers u\n#6647    btracey x/tools/cmd/godoc: display type kind of each named type\n#4237  gjemiller encoding/base64: URLEncoding padding is optional\n//!-textoutput\n*/\n</code></pre>\n<p>代码实现了查找指定github仓库中指定关键词对应的issue的编号，发布者id，问题的描述</p>\n<h3>练习4.10</h3>\n<p>修改issues程序，实现对输出的问题进行分类，分别是不超过一个月、不到一年、超过一年三类issue</p>\n<p>我的思路：获取当前时间信息（使用time.Now)，当前时间减去发布时间（.Sub）获得新的时间（time.Time类型），获取小时数（.Hour）然后比较是否超过了一个月或者一年</p>\n<p>代码：</p>\n<pre><code class=\"language-go\">// Copyright © 2016 Alan A. A. Donovan &#x26; Brian W. Kernighan.\n// License: https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// See page 112.\n//!+\n\n// Issues prints a table of GitHub issues matching the search terms.\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"gopl.io/ch4/github\"\n)\n\n// !+\nfunc main() {\n\tresult, err := github.SearchIssues(os.Args[1:])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"%d issues:\\n\", result.TotalCount)\n\n//---------------修改开始的地方-------------------\n\tcurrentTime := time.Now()\n\tpartItem := make(map[string][]*github.Issue, 3) //三类问题的map 不超过一个月 不超过一年 超过一年\n\tpartItem[\"不超过一个月\"] = make([]*github.Issue, 0)\n\tpartItem[\"不超过一年\"] = make([]*github.Issue, 0)\n\tpartItem[\"超过一年\"] = make([]*github.Issue, 0)\n\tmonthTime := 30 * 24\n\tyearTime := monthTime*12 + 5*24\n\tfor _, item := range result.Items {\n\t\tswitch timeLag := currentTime.Sub(item.CreatedAt); {\n\t\tcase timeLag.Hours() &#x3C; float64(monthTime):\n\t\t\tpartItem[\"不超过一个月\"] = append(partItem[\"不超过一个月\"], item)\n\t\tcase timeLag.Hours() &#x3C; float64(yearTime):\n\t\t\tpartItem[\"不超过一年\"] = append(partItem[\"不超过一年\"], item)\n\t\tdefault:\n\t\t\tpartItem[\"超过一年\"] = append(partItem[\"超过一年\"], item)\n\t\t}\n\t}\n\n\tfor index, item := range partItem {\n\t\tfmt.Println(index)\n\t\tfor j := 0; j &#x3C; len(item); j++ {\n\t\t\tinnerItem := item[j]\n\t\t\tfmt.Printf(\"#%-5d %9.9s %.55s %s\\n\",\n\t\t\t\tinnerItem.Number, innerItem.User.Login, innerItem.Title, innerItem.CreatedAt)\n\t\t}\n\t}\n//---------------修改结束的地方-------------------\n}\n\n//!-\n\n/*\n//!+textoutput\n$ go build gopl.io/ch4/issues\n$ ./issues repo:golang/go is:open json decoder\n13 issues:\n#5680    eaigner encoding/json: set key converter on en/decoder\n#6050  gopherbot encoding/json: provide tokenizer\n#8658  gopherbot encoding/json: use bufio\n#8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal\n#5901        rsc encoding/json: allow override type marshaling\n#9812  klauspost encoding/json: string tag not symmetric\n#7872  extempora encoding/json: Encoder internally buffers full output\n#9650    cespare encoding/json: Decoding gives errPhase when unmarshalin\n#6716  gopherbot encoding/json: include field name in unmarshal error me\n#6901  lukescott encoding/json, encoding/xml: option to treat unknown fi\n#6384    joeshaw encoding/json: encode precise floating point integers u\n#6647    btracey x/tools/cmd/godoc: display type kind of each named type\n#4237  gjemiller encoding/base64: URLEncoding padding is optional\n//!-textoutput\n*/\n\n</code></pre>\n<p>可以实现正常的输出。</p>\n<p>遇到的问题：</p>\n<ul>\n<li>\n<p>一开始的思路是创建二维slice，然后不同的行表示不同的类别，同一行的不同列表示同一个类的不同issue；这样做的问题是意义不明确，不如创建一个map，把类别和对应的slice做映射</p>\n</li>\n<li>\n<p>创建每一个类别的slice时使用 <code>make([]github.Issue,0)</code>而不是 <code>make([]*github.Issue,0)</code>导致最后出错，使用复合类型时最好在前面带*号；包括在结构体内使用其他结构体的类型时，样例里给出的也是带*号的</p>\n<pre><code class=\"language-go\">type Issue struct {\n\tNumber    int\n\tHTMLURL   string `json:\"html_url\"`\n\tTitle     string\n\tState     string\n\tUser      *User\n\tCreatedAt time.Time `json:\"created_at\"`\n\tBody      string    // in Markdown format\n}\n</code></pre>\n</li>\n<li>\n<p>使用hour来判断时间是否过了一个月或者一年误差比较大，可以直接使用月份之差或者年份之差来判断</p>\n<p>别人的程序：</p>\n<pre><code class=\"language-go\">func Process(data *IssuesSearchResult) {\n\t// 创建一个hash表\n\thash := make(map[string][]*Issue, 3)\n\thash[\"不到一月\"] = make([]*Issue, 0)\n\thash[\"不到一年\"] = make([]*Issue, 0)\n\thash[\"超过一年\"] = make([]*Issue, 0)\n\t// 遍历数据\n\tfor _, val := range data.Items {\n\t\t// 获取现在的时间\n\t\tnow := time.Now()\n\t\tyear := now.Year()\n\t\tmonth := now.Month()\n\t\t// 创建时间\n\t\tcreate_year := val.CreatedAt.Year()\n\t\tcreate_month := val.CreatedAt.Month()\n\t\tif year == create_year &#x26;&#x26; month == create_month {\n\t\t\thash[\"不到一月\"] = append(hash[\"不到一月\"], val)\n\t\t} else if year == create_year {\n\t\t\thash[\"不到一年\"] = append(hash[\"不到一年\"], val)\n\t\t} else {\n\t\t\thash[\"超过一年\"] = append(hash[\"超过一年\"], val)\n\t\t}\n\t}\n\tfmt.Printf(\"数据总条数，%v\\n\", data.TotalCount)\n\tfor key, val := range hash {\n\t\tfmt.Printf(\"%s:\\n\", key)\n\t\tfor _, v := range val {\n\t\t\tfmt.Printf(\"#%-5d %9.9s %.55s %9.9v\\n\",\n\t\t\t\tv.Number, v.User.Login, v.Title, v.CreatedAt)\n\t\t}\n\t}\n}\n</code></pre>\n<p>这样判断可以精确一点，不会出现某些时刻判断不准确的情况</p>\n</li>\n<li>\n<p>可以把对数据的操作封装成一个函数，这样main函数体内的代码会更简洁一点；同时可以让用户在不用分类输出的时候可以选择直接输出所有内容</p>\n</li>\n</ul>\n<h3>练习4.12</h3>\n<p>描述：流行的web漫画服务xkcd也提供了JSON接口。例如，一个 https://xkcd.com/571/info.0.json 请求将返回一个很多人喜爱的571编号的详细描述。下载每个链接（只下载一次）然后创建一个离线索引。编写一个xkcd工具，使用这些离线索引，打印和命令行输入的检索词相匹配的漫画的URL。</p>\n<p>解决思路:</p>\n<ul>\n<li>首先查看网站的规律，发现https://xkcd.com/是基本的域名，后面跟上漫画的编号，最后跟上/info.0.json表示查看json信息；所以定义一个baseUrl，然后写一个循环获取所有的json文件，将他们存放到csv文件中</li>\n<li>需要获取到的属性有title，img，link；所以需要定义结构体，里面的成员有title，img，link；并且标签上解释了json编码的名称</li>\n<li>获取用户的关键词可以采用os.Args[1:]，判断是否含有该漫画可以采用模糊搜索，在所有的记录中查询关键词是否被包含在某一条记录中的title里面；如果有则输出该条记录</li>\n<li>读取csv文件的方式可以采用csv.NewReader()创建reader，然后通过循环调用reader的函数Read，直到读取到io.EOF停止读取内容；每读一条内容就匹配一下是否符合关键词，如果符合就输出。</li>\n</ul>\n<p>我的程序：</p>\n<pre><code class=\"language-go\">//test.go\npackage test\n\nimport (\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\nconst BaseUrl = \"https://xkcd.com/\"\nconst filename = \"xkcd.csv\"\n\ntype DataInfo struct {\n\tTitle string `json:\"title,omitempty\"`\n\tImg   string `json:\"img,omitempty\"`\n\tLink  string `json:\"link,omitempty\"`\n}\n\nfunc Download() {\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer f.Close()\n\t//创建writer\n\twriter := csv.NewWriter(f)\n\t//使用writer向csv写入内容\n\twriter.Write([]string{\"title\", \"link\", \"img\"})\n\t//循环获取每条数据\n\tvar dataInfo DataInfo\n\tfor i := 1; i &#x3C; 10; i++ {\n\t\t//发送http get请求\n\t\tfmt.Println(i)\n\t\tcurrentUrl := fmt.Sprintf(\"%s%d\", BaseUrl, i)\n\t\tres, err := http.Get(currentUrl + \"/info.0.json\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\t// 如果已经到最后一个漫画，页面返回404，返回的状态码不是200\n\t\tif res.StatusCode != http.StatusOK {\n\t\t\tfmt.Println(\"没有更多漫画了\")\n\t\t\tbreak\n\t\t}\n\t\terr = json.NewDecoder(res.Body).Decode(&#x26;dataInfo)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\t// 将内容存储到csv中\n\t\twriter.Write([]string{dataInfo.Title, dataInfo.Link + currentUrl, dataInfo.Img})\n\t\t// 将缓存内容写入csv中\n\t\twriter.Flush()\n\t}\n}\n\nfunc Search(args string) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer f.Close()\n\treader := csv.NewReader(f)\n\tvar hasfind bool\n\tfor {\n\t\tresult, err := reader.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif strings.Contains(strings.ToLower(result[0]), args) {\n\t\t\tfmt.Printf(\"link: %s; img link: %s\\n\", result[1], result[2])\n\t\t\thasfind = true\n\t\t}\n\t}\n\tif !hasfind {\n\t\tfmt.Println(\"没有找到此漫画\")\n\t}\n}\n\n</code></pre>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"ex4.12/test\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// test.Download()\n\tkey := os.Args[1:]\n\ttest.Search(strings.Join(key, \" \"))\n}\n\n</code></pre>\n<p>第一次执行的时候先运行test.Download()，然后执行test.Search()查找关键词对应的漫画链接</p>\n<h3>练习4.13</h3>\n<p>描述：使用开放电影数据库的JSON服务接口，允许你检索和下载 https://omdbapi.com/ 上电影的名字和对应的海报图像。编写一个poster工具，通过命令行输入的电影名字，下载对应的海报。</p>\n<p>我的思路：</p>\n<ul>\n<li>类似练习4.12，首先定义baseUrl和这个网站的apikey，然后构造发出的请求url，通过http.Get获取返回的json</li>\n<li>定义结构体获取返回的json中我们感兴趣的属性（例如title，poster，imdbID等）</li>\n<li>创建.jpg格式的文件，然后使用jpeg库decode poster url中的数据，存储到image.Image类型的对象中；之后通过encode存储到文件中</li>\n</ul>\n<p>我的程序：</p>\n<pre><code class=\"language-go\">//test.go\npackage contact\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/jpeg\"\n\t\"net/http\"\n\t\"os\"\n)\n\nconst (\n\tbaseUrl = \"https://omdbapi.com/\"\n\tapiKey  = \"bb3ad877\"\n)\n\ntype movie struct {\n\tTitle  string `json:\"Title,omitempty\"`\n\tPoster string `json:\"Poster,omitempty\"`\n\tImdbID string `json:\"imdbID\"`\n}\n\nfunc Query(title string) {\n\tres, err := http.Get(fmt.Sprintf(\"%s?apikey=%s&#x26;t=%s\", baseUrl, apiKey, title))\n\tif err != nil {\n\t\tfmt.Println(\"请求发送失败\")\n\t\tpanic(err)\n\t}\n\tif res.StatusCode != http.StatusOK {\n\t\tfmt.Printf(\"请求不成功，状态码是%d\\n\", res.StatusCode)\n\t\tos.Exit(1)\n\t}\n\tvar movies movie\n\terr = json.NewDecoder(res.Body).Decode(&#x26;movies)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tres, err = http.Get(movies.Poster)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar img image.Image\n\timg, err = jpeg.Decode(res.Body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tf, _ := os.OpenFile(fmt.Sprintf(\"%s.jpg\", movies.ImdbID), os.O_RDWR|os.O_CREATE, 0666)\n\tdefer f.Close()\n\tjpeg.Encode(f, img, nil)\n}\n\n</code></pre>\n<pre><code class=\"language-go\">//main.go\npackage main\n\nimport (\n\t\"Ex4.13/contact\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\ttitle := os.Args[1:]\n\tcontact.Query(strings.Join(title, \" \"))\n}\n\n</code></pre>\n<h4>附：go语言处理图片</h4>\n<h5>base64 转 file</h5>\n<pre><code class=\"language-go\">ddd, _ := base64.StdEncoding.DecodeString(datasource) //成图片文件并把文件写入到buffer\nerr2 := ioutil.WriteFile(\"./output.jpg\", ddd, 0666)   //buffer输出到jpg文件中（不做处理，直接写到文件）\n\n</code></pre>\n<h5>base64 转 buffer</h5>\n<pre><code class=\"language-go\">ddd, _ := base64.StdEncoding.DecodeString(datasource) //成图片文件并把文件写入到buffer\nbbb := bytes.NewBuffer(ddd)                           // 必须加一个buffer 不然没有read方法就会报错\n\n</code></pre>\n<h5>buffer 转 ImageBuff(代码接上面的代码)</h5>\n<pre><code class=\"language-go\">m, _, _ := image.Decode(bbb)                                       // 图片文件解码\nrgbImg := m.(*image.YCbCr)\nsubImg := rgbImg.SubImage(image.Rect(0, 0, 200, 200)).(*image.YCbCr) //图片裁剪x0 y0 x1 y1\n\n</code></pre>\n<h5>img 转 file（代码接上面的代码）</h5>\n<pre><code class=\"language-go\">f, _ := os.Create(\"test.jpg\")     //创建文件\ndefer f.Close()                   //关闭文件\njpeg.Encode(f, subImg, nil)       //写入文件\n\n</code></pre>\n<h5>img 转 base64（代码接上面的代码）</h5>\n<pre><code class=\"language-go\">emptyBuff := bytes.NewBuffer(nil)                  //开辟一个新的空buff\njpeg.Encode(emptyBuff, subImg, nil)                //img写入到buff\ndist := make([]byte, 50000)                        //开辟存储空间\nbase64.StdEncoding.Encode(dist, emptyBuff.Bytes()) //buff转成base64\nfmt.Println(string(dist))                          //输出图片base64(type = []byte)\n_ = ioutil.WriteFile(\"./base64pic.txt\", dist, 0666) //buffer输出到jpg文件中（不做处理，直接写到文件）\n\n</code></pre>\n<h5>imgFile 转 base64</h5>\n<pre><code class=\"language-go\">ff, _ := ioutil.ReadFile(\"output2.jpg\")               //我还是喜欢用这个快速读文件\nbufstore := make([]byte, 5000000)                     //数据缓存\nbase64.StdEncoding.Encode(bufstore, ff)               // 文件转base64\n_ = ioutil.WriteFile(\"./output2.jpg.txt\", dist, 0666) //直接写入到文件就ok完活了。\n\n</code></pre>\n","title":"Go和json交互简单介绍","date":"2023-07-31","category":"GO","tags":["GO"],"summary":"介绍Go语言和JSON交互的简单操作","views":0}},"__N_SSG":true}