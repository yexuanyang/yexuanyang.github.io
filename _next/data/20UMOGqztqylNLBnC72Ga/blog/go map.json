{"pageProps":{"article":{"id":"go map","contentHtml":"<h2>key类型</h2>\n<p>可以是任何可以使用==或!=比较的类型；数组，切片，结构体不能作为key类型；基本数据类型和接口类型可以作为key类型</p>\n<p>如果要使用结构体作为key类型，需要提供key（）和hash（）方法</p>\n<h2>value类型</h2>\n<p>任意类型，可以使用空接口来存储任意类型，使用时需要一次<em>类型断言</em></p>\n<p>value中存储函数可以实现分支的结构，使用map中的key来选择函数</p>\n<pre><code class=\"language-go\">package main\r\nimport \"fmt\"\r\nfunc main() {\r\nmf := map[int]func() int{\r\n\t1: func() int { return 10 },\r\n\t2: func() int { return 20 },\r\n\t5: func() int { return 50 },\r\n}\r\nfmt.Println(mf)\r\n}\n</code></pre>\n<p>对于一个key对应多个value的情况，可以使用切片作为类型</p>\n<p>例如</p>\n<pre><code class=\"language-go\">mp1 := make(map[int][]int)\r\nmp2 := make(map[int]*[]int)\n</code></pre>\n<h2>初始化</h2>\n<p>不赋值： <code>map1 := make(map[string]int)</code></p>\n<p>赋值：<code>map1 := map[string]int{\"1234\":2,\"keuw\":12}</code></p>\n<p>不要使用new来创建map，如果你错误的使用 new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未\r\n初始化的变量并且取了它的地址</p>\n<h2>赋值</h2>\n<p>如果key是map的一个值， <code>map[key]</code>表示key对应的值；给key对应的值赋值方法：<code>map[key] = val1</code></p>\n<p>将key的值导出 <code>v := map[key]</code>如果key不存在，那么v是value类型的空值</p>\n<h2>容量</h2>\n<p>在make map的时候可以指定map的容量，超出容量会自动+1作为新的容量；</p>\n<p>对于提前知道容量的map或者可能快速扩容的map应当提前指定容量</p>\n<p>指定方式：<code>make(map[string]int, 2)</code>第二个参数2就是容量</p>\n<h2>测试键值对是否存在</h2>\n<p><code>val, isPresent := map1[\"123\"]</code>如果不存在那么isPresent是false</p>\n<h2>删除键值对</h2>\n<p><code>delete(map,key)</code></p>\n<p>例如 <code>delete(map1,\"123\")</code>删除了map1中key为123的键值对</p>\n<h2>for range遍历map</h2>\n<pre><code class=\"language-go\">for key,value := range map{\r\n}\n</code></pre>\n<p>这样可以遍历一个map，key表示键，value表示值</p>\n<p>map不是按照key排序也不是按照value排序的</p>\n<p>例如：</p>\n<pre><code class=\"language-go\">capitals := map[string] string {\"France\":\"Paris\", \"Italy\":\"Rome\", \"Japan\":\"Tokyo\" }\r\nfor key := range capitals {\r\nfmt.Println(\"Map item: Capital of\", key, \"is\", capitals[key])\r\n}\r\n\n</code></pre>\n<p>这段代码的输出如下：</p>\n<pre><code class=\"language-plaintext\">Map item: Capital of Italy is Rome\r\nMap item: Capital of Japan is Tokyo\r\nMap item: Capital of France is Paris\n</code></pre>\n<h2>map类型切片</h2>\n<p>看下面的代码:</p>\n<pre><code class=\"language-go\">package main\r\nimport \"fmt\"\r\nfunc main() {\r\n// Version A:\r\nitems := make([]map[int]int, 5)\r\nfor i:= range items {\r\nitems[i] = make(map[int]int, 1)\r\nitems[i][1] = 2\r\n}\r\nfmt.Printf(\"Version A: Value of items: %v\\n\", items)\r\n// Version B: NOT GOOD!\r\nitems2 := make([]map[int]int, 5)\r\nfor _, item := range items2 {\r\nitem = make(map[int]int, 1) // item is only a copy of the slice element.\r\nitem[1] = 2 // This 'item' will be lost on the next iteration.\r\n}\r\nfmt.Printf(\"Version B: Value of items: %v\\n\", items2)\r\n}\r\n\n</code></pre>\n<p>VersionA的代码真正修改了map,但是VersionB的代码没有修改map,因为遍历的时候取出的item是map的一个复制品,在下一次迭代之后数据就丢失了,不会更改原来的map</p>\n<h2>map排序</h2>\n<p>map默认是无序的,如果需要排序,可以将键取出来,作为一个切片,然后对切片排序,再从map中取数据</p>\n<p>如果需要有序的map,建议使用结构体切片,结构体如下:</p>\n<pre><code class=\"language-go\">type mymap strcut{\r\n\tkey string\r\n\tvalue int\r\n}\n</code></pre>\n<h2>map键值对换</h2>\n<p>如果键值是一一对应的,那么可以直接使用for-range方式遍历map然后对换即可</p>\n<p>如果键值是多对一,即可能不同的键有相同的值,那么对换之后一个键就有多个值,所以需要更换新map的类型</p>\n<p>如果是 <code>map[string]int</code>对换,那么保险起见可以使用 <code>map[int][]string</code>作为对换之后的类型</p>\n","title":"Go Map的使用指南","date":"2023-07-31","category":"GO","tags":["GO"],"summary":"介绍Go语言中Map的key和value类型使用规则","views":0}},"__N_SSG":true}